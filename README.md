# Golang 101

## 逃逸分析

调用 `new()` 函数得到的内存不一定在堆上，可能在栈上，由 Go 编译器在后台完成，做到变量内存的**按需分配**。

> 在堆上创建的变量，没有删除，忘记释放内存，就发生了内存泄漏。**很多现代语言都有垃圾回收机制**。

在编译原理中，分析指针动态范围的方法称为逃逸分析。

- 栈上内存分配比堆上快，只需要执行 PUSH 指令，并且会自动释放内存。
- 堆适合**不可预知大小**（如函数的参数为 `interface`）的内存分配，代价是速度慢，会形成内存碎片。堆不像栈可以自动清理，会引起运行时的频繁垃圾回收，垃圾回收占用的系统开销比较大。

**逃逸分析最基本原则：如果一个函数返回对一个变量的引用，那么这个变量就好发生逃逸**。

编译器证明该变量在函数返回后不在被引用，才会分配在栈上，其他都情况分配在堆上。编译器会根据变量是否被外部引用来决定是否逃逸：

1. 如果变量在函数外部没有引用，优先分配在栈上（定义一个很大的数组，需要申请的内存过大，超过栈的存储能力）
2. 如果变量在函数外部存在引用，必定分配在堆上

```shell
go build -gcflags '-m -l' main.go

# -m：输出编译器的优化细节（包括使用逃逸分析）
# -l：禁止函数内联优化，防止逃逸被编译器通过内联彻底的抹除
# -N：关闭编译器优化

go tool compile -S main.go

# 输出结果中 newobject 函数用于在堆上分配一块内存
```

一般程序的堆栈是指操作系统级别的概念，由语言的编译器和系统环境共同决定。程序启动时，操作系统会自动维护一个所启动程序消耗内存的地址空间，并自动将这个空间从逻辑上划分为堆内存和栈内存（保存局部变量或者函数调用栈）。

传统意义上的栈被 Go 语言运行时全部消耗，用于维护运行时各个组件之间的协调，如调度器，垃圾回收，系统调用等。对于用户态的 Go 代码消耗的堆和栈，只是 Go 运行时通过管理向操作系统申请的堆内存，构造的逻辑上的堆和栈，本质都是堆内存。因此，相对于传统的栈只有 1M 的大小，Go 程序拥有几乎无限的栈内存（1GB）。

**对于用户态 Go 代码消耗的栈内存，Go 运行时会防止内存碎片化，在适当的时候堆整个栈进行深拷贝，将其复制到另一个区域，因此指针的算术运行不能奏效，在没有特殊说明的情况下，无法确定运算前后指针所指的地址内容是否被 Go 运行时移动**。

## defer

> defer 能把资源的释放语句和申请语句放在距离相近的位置（通常成对出现），从而减少资源泄露的情况发生。

defer 是 Go 语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（通过 `return` 正常结束或者 `panic` 导致异常结束）执行。**defer 会有短暂延迟，对时间要求特别高的程序，可以避免使用**，且不能多重 defer 进行嵌套。

```golang
// 举个例子
r.mu.Lock()
rand.Intn(param)
r.mu.Unlock()

// 虽然上面只有 3 行，但是还是有必要使用 defer
// 1. 第 2 行可能出现 panic 的情况
// 2. 可能之后会在第 1 和 3 行之间增加新的逻辑
```

每次 defer 语句执行的时候，会把函数“压栈”，函数参数复制下来（注意值，引用和闭包的区分）；当外层函数（不是代码块，比如 for 循环块并不是外层函数）退出时，defer 函数按照定义的顺序逆序执行（后面定义的函数可能会依赖前面的资源）；**如果 defer 执行的函数为 `nil`，那么会在最终调用函数的时候产生 `panic`**。

defer 语句的执行可以拆解为 3 条指令：

1. 当存在命名返回值时，返回值=xxx
2. 调用 defer 函数
3. 空的 return

```golang
func f() (r int){
    t := 5

    defer func(){
        t += 5
    }

    return t
}

// 根据上面的分析，可以拆解为
func f() (r int){
    t := 5

    // 指令1
    r = t

    // 指令2
    func (){
        t += 5
    }

    // 指令3
    return
}
```

通常程序需要从 `panic` 中恢复，或者至少在程序奔溃前做一些清理工作。因为 `panic` 会停掉当前正在执行的程序，而不是当前线程，在停止程序之前，它会有序地执行完当前线程 defer 列表里的语句，其他协程里定义的 defer 语句不作保证。

因此，可以且只可以在 defer 的函数中执行 `recover()` 函数，来防止程序直接挂掉，如果直接调用 `recover()` 函数，会返回 `nil`。

> `goroutine` 被设计为一个独立的代码执行单元，拥有自己的执行栈，不与其他 `goroutine` 共享任何数据。这意味着，无法让 `goroutine` 应有返回值，也无法让 `goroutine` 拥有自身的 ID 等。一般都是通过 channel 方式或者共享内存同步方式对共享的内存添加读写锁实现 `goroutine` 之间的通信。因此，无法 recover 其他 goroutine 里面的 panic。

**并发读写 map 是一个不可恢复的 panic**。

## 闭包

> 变量作为函数的参数，在函数定义的时候就会被求值，注意值与地址的区别。

闭包（匿名函数）是由函数及其相关引用环境组合而成的实体，即：**闭包 = 函数 + 引用环境**。在 Go 语言中，所有的匿名函数都是闭包，匿名函数可以直接调用，也可以赋值给变量。

闭包继承了函数声明时的作用域，它会将同一个作用域内的变量和常量捕获下来（获取的地址，即引用传递），无论闭包在什么地方被调用，都可以使用这些变量和常量。

```golang
package main

import "fmt"

func main(){
    var a = accumulator()
    fmt.Printf("%d\n",a(1))
    fmt.Printf("%d\n",a(10))
    fmt.Printf("%d\n",a(100))

    fmt.Println("------------------------")

    var b = accumulator()
    fmt.Printf("%d\n",b(1))
    fmt.Printf("%d\n",b(10))
    fmt.Printf("%d\n",b(100))
}

func accumulator() func(int)int{
    var x int

    // 函数的返回值是一个闭包，捕获了上面的变量 x 
    return func(delta int)int{
        fmt.Printf("%+v,%+v\t|\t",&x,x)
        x+=delta
        return x
    }
}

// 结果
0xc000018088,0 | 1
0xc000018088,1 | 11
0xc000018088,11 | 111
------------------------
0xc0000180a0,0 | 1
0xc0000180a0,1 | 11
0xc0000180a0,11 | 111
```

**闭包中的变量的值，根据闭包执行时的上下文确定**。
